#######################
# MODALDECOMP LIBRARY #
#######################

Check for unexpected memory usage.  Some trial runs show that
max_fields_per_node does not prevent crashes as expected.  This occurs when
there are two or more chunks in the inner product matrix.  A possible cure would
be to delete the lists of snapshots at the end of each loop iteration, clearing
this memory completely before generating new data to take its place.


Find a better, more natural, way to deal with line continuation/breaks. As it is,
the code is chopped to bits and is not at all readable. No one would ever write
code like this, and that's why we always have to go back and redo the formatting.
It's completely imposed and unnatural currently.

add an option for svd thresholding in DMD.  when the svd singular values are
ill-conditioned, then the resulting computation results can be invalid.  for
instance the mode norms may come out negative...(when computed using
coefficients rather than the modes themselves).

snapNum and similar should be called snapIndex. This is because the "number" of a mode
is generally different than its index. The most common example of this is the
first mode is called mode number 1 but has index 0 (indexFrom=1). To be clear, I
differentiate between a mode number and mode index. To be consistent with all
naming conventions, index should be used instead of num when referring to some
object's "index" internally and starting from 0.  Number is more of a
name, index is hidden from the user and starts from 0.
  - This has been done for fieldopersations and bpod, and their tests. All future
    code should make the distinction between xxxNum and xxxIndex notation.


The tests for DMD should be updated so that we check that the internal POD
object has the correct arguments passed to it.


Write tests directly for lin_combine in fieldoperations, not just
_compute_modes.

Rename/move _compute_modes. As it is, it doesn't make sense to be in
fieldoperations.


Profiling with cProfile could expose potentially easy speed increases.  However,
some of these results could be dependent on the user's use of the library, we
shouldn't optimize for a particular case at expense of other cases. Use on benchmark.py.

Automatically detect the maxFieldsPerNode. This would require some fancier
things, like determining the available RAM and the size of a snapshot object. It
might not be possible since some memory is used by the snap/mode objects when
doing inner products, etc. We could leave a safety factor though, and maybe
leave space for 1-2 snaps/modes for scratch space for the user's functions. 




################# 
## ROM LIBRARY ##
#################

This is a separate library that would compute ROMs. It would interact well with
modaldecomp when necessary (for example for BPOD). The main idea is that there
would be a base class that defined mostly the interface, and derived classes
that would implement computing the ROM ODEs for a specific PDE. The easiest
example would be computing a ROM that is an LTI system with: dx/dt = Ax + Bu y =
Cx (+ Du) This has been done (by Brandt) for the BPOD case (see bpodltirom.py).
The A, B, and C matrices are computed, given the direct modes, the adjoint
modes, and the direct modes advanced one small time step (these are used to
calculate the time- derivatives of the direct modes via finite difference).
More thought needs to be put into this before it is attempted, but it might be
able to handle general PDEs and general forms of the ROM.




